---
// Search.astro
---

<div id="search-container" class="search-container hidden">
    <div class="search-input-wrapper">
        <input
            type="text"
            id="search-input"
            class="search-input"
            placeholder="Try `design`, `ui` or `art`"
            autocomplete="off"
        />
        <button
            id="search-close"
            class="search-close"
            aria-label="Close search"
        >
            <svg
                width="32"
                height="32"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
            >
                <path d="M18 6L6 18M6 6l12 12"></path>
            </svg>
        </button>
    </div>
    <div id="search-results" class="search-results">
        <!-- Results will be inserted here -->
    </div>
</div>

<style>
    .search-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: white;
        z-index: 9999;
        overflow-y: auto;
        padding: 2rem 1rem;
    }

    .search-container.hidden {
        display: none;
    }

    .search-input-wrapper {
        max-width: 1200px;
        margin: 0 auto 3rem;
        position: relative;
        padding: 0 1rem;
    }

    .search-input {
        width: 100%;
        padding: 1.5rem 4rem 1.5rem 0;
        font-size: 72px;
        line-height: 1.2;
        font-weight: 300;
        border: none;
        outline: none;
        background: transparent;
        border-bottom: 2px solid #e5e7eb;
        transition: border-color 0.2s;
        min-height: 100px;
    }

    .search-input:focus {
        border-bottom-color: #111827;
    }

    .search-input::placeholder {
        color: #d1d5db;
    }

    .search-suggestions {
        margin-bottom: 2rem;
    }

    .search-suggestions-note {
        font-size: 0.875rem;
        color: #9ca3af;
        margin-top: 1rem;
    }

    .search-suggestions-label {
        font-size: 1rem;
        color: #6b7280;
        margin-bottom: 0.75rem;
    }

    .search-suggestions-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .search-suggestion-item {
        position: relative;
        padding: 0.5rem 1rem 0.5rem 2.5rem;
        background: #f3f4f6;
        border: 1px solid #e5e7eb;
        border-radius: 0.375rem;
        font-size: 1rem;
        color: #374151;
        cursor: pointer;
        transition: all 0.2s;
    }

    .search-suggestion-shortcut {
        position: absolute;
        left: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.75rem;
        color: #6b7280;
        font-family: monospace;
    }

    .search-suggestion-item:hover {
        background: #e5e7eb;
        border-color: #d1d5db;
    }

    .search-mixed-results {
        display: flex;
        flex-direction: column;
        gap: 2rem;
    }

    .search-suggestion-group {
        border-bottom: 1px solid #e5e7eb;
        padding-bottom: 2rem;
    }

    .search-suggestion-group:last-child {
        border-bottom: none;
    }

    .search-suggestion-header {
        font-size: 1.125rem;
        font-weight: 500;
        color: #374151;
        margin-bottom: 1rem;
    }

    .search-close {
        position: absolute;
        right: 1rem;
        top: 50%;
        transform: translateY(-50%);
        padding: 0.75rem;
        background: none;
        border: none;
        cursor: pointer;
        color: #6b7280;
        transition: color 0.2s;
    }

    .search-close:hover {
        color: #111827;
    }

    .search-results {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 1rem;
    }

    /* Grid handled by Tailwind classes */

    .search-result-item {
        aspect-ratio: 1;
        background: white;
        border: 1px solid rgb(229 231 235);
        border-radius: 0.5rem;
        overflow: hidden;
        position: relative;
        transition: box-shadow 0.2s;
        cursor: pointer;
    }

    .search-result-item:hover {
        box-shadow:
            0 20px 25px -5px rgba(0, 0, 0, 0.1),
            0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    .search-result-link {
        width: 100%;
        height: 100%;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        text-decoration: none;
        color: inherit;
    }

    .search-result-title {
        font-size: 1.125rem;
        font-weight: 600;
        color: black;
        margin-bottom: 0.5rem;
        line-height: 1.25;
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
    }

    .search-result-description {
        font-size: 0.875rem;
        color: rgb(107 114 128);
        margin-bottom: 1rem;
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
    }

    .search-result-content {
        font-size: 0.875rem;
        color: rgb(31 41 55);
        line-height: 1.75;
        position: relative;
        flex-grow: 1;
    }

    .search-result-content p {
        white-space: pre-wrap;
    }

    .search-result-content mark {
        background-color: transparent;
        color: inherit;
        font-weight: 600;
    }

    .search-result-fade {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 8rem;
        background: linear-gradient(
            to top,
            white,
            rgba(255, 255, 255, 0.9),
            transparent
        );
        pointer-events: none;
    }

    .search-no-results {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
        font-size: 1.125rem;
    }

    .search-loading {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
        font-size: 1.125rem;
    }

    @media (max-width: 768px) {
        .search-input {
            font-size: 48px;
        }
    }

    @media (max-width: 480px) {
        .search-input {
            font-size: 36px;
        }
    }

    .flex-grow {
        flex-grow: 1;
    }
</style>

<script>
    declare global {
        interface Window {
            tinysearchInit: any;
            tinysearchSearch: any;
            searchIndex: any[];
            wordIndex: any;
        }
    }

    let wasmInitialized = false;
    let searchContainer: HTMLElement;
    let searchInput: HTMLInputElement;
    let searchResults: HTMLElement;
    let searchClose: HTMLElement;
    let currentSuggestions: string[] = [];

    // Initialize elements
    function initializeElements() {
        searchContainer = document.getElementById("search-container")!;
        searchInput = document.getElementById(
            "search-input",
        ) as HTMLInputElement;
        searchResults = document.getElementById("search-results")!;
        searchClose = document.getElementById("search-close")!;
    }

    // Load the search index
    async function loadSearchIndex() {
        if (!window.searchIndex) {
            try {
                const response = await fetch("/search-index.json");
                window.searchIndex = await response.json();
            } catch (error) {
                console.error("Failed to load search index:", error);
            }
        }
    }

    // Load word index for partial matching
    async function loadWordIndex() {
        if (!window.wordIndex) {
            try {
                const response = await fetch("/word-index.json");
                window.wordIndex = await response.json();
            } catch (error) {
                console.error("Failed to load word index:", error);
            }
        }
    }

    // Find partial matches in word index
    function findPartialMatches(query: string, limit: number = 10): string[] {
        if (!window.wordIndex || !window.wordIndex.words || query.length < 2) {
            return [];
        }

        const lowerQuery = query.toLowerCase();
        const matches: Array<{ word: string; count: number }> = [];

        // Find words that start with the query
        for (const entry of window.wordIndex.words) {
            if (entry.word.startsWith(lowerQuery)) {
                matches.push(entry);
                if (matches.length >= limit * 2) break;
            }
        }

        // Sort by frequency and take top results
        matches.sort((a, b) => b.count - a.count);
        return matches.slice(0, limit).map((m) => m.word);
    }

    // Load WASM module script
    function loadWasmScript(): Promise<void> {
        return new Promise((resolve, reject) => {
            // Check if already loaded
            if (window.tinysearchInit) {
                resolve();
                return;
            }

            const script = document.createElement("script");
            script.type = "module";
            script.onload = () => resolve();
            script.onerror = () =>
                reject(new Error("Failed to load search script"));

            // Set the script content to load the module
            script.textContent = `
                import init, { search } from '/wasm/tinysearch_engine.js';
                window.tinysearchInit = init;
                window.tinysearchSearch = search;
            `;

            document.head.appendChild(script);
        });
    }

    // Initialize WASM
    async function initializeWasm() {
        if (!wasmInitialized) {
            try {
                await loadWasmScript();
                await window.tinysearchInit("/wasm/tinysearch_engine_bg.wasm");
                wasmInitialized = true;
            } catch (error) {
                console.error("Failed to initialize search:", error);
            }
        }
    }

    // Find matching text with context
    function findMatchingContext(
        text: string,
        query: string,
        contextLength: number = 100,
    ): string | null {
        const lowerText = text.toLowerCase();
        const lowerQuery = query.toLowerCase();
        const index = lowerText.indexOf(lowerQuery);

        if (index === -1) return null;

        // Calculate start and end with context
        let start = Math.max(0, index - contextLength);
        let end = Math.min(text.length, index + query.length + contextLength);

        // Try to find word boundaries
        if (start > 0) {
            const spaceIndex = text.lastIndexOf(" ", start);
            if (spaceIndex > start - 20) start = spaceIndex + 1;
        }

        if (end < text.length) {
            const spaceIndex = text.indexOf(" ", end);
            if (spaceIndex !== -1 && spaceIndex < end + 20) end = spaceIndex;
        }

        // Extract the text with ellipsis if needed
        let excerpt = text.substring(start, end);
        if (start > 0) excerpt = "..." + excerpt;
        if (end < text.length) excerpt = excerpt + "...";

        // Highlight the matching text
        const highlightRegex = new RegExp(`(${query})`, "gi");
        excerpt = excerpt.replace(highlightRegex, "<mark>$1</mark>");

        return excerpt;
    }

    // Perform search
    async function performSearch(query: string) {
        if (!wasmInitialized) {
            searchResults.innerHTML =
                '<div class="search-loading">Initializing search...</div>';
            await initializeWasm();
            await loadSearchIndex();
            await loadWordIndex();
        }

        if (!query.trim()) {
            searchResults.innerHTML = "";
            currentSuggestions = [];
            return;
        }

        // Check if query matches any word completely
        const lowerQuery = query.toLowerCase();
        const words = lowerQuery.split(/\s+/).filter((w) => w.length > 0);
        const lastWord = words[words.length - 1];

        // Find partial matches for the last word
        const partialMatches = findPartialMatches(lastWord);

        // Check if we have exact matches or should show suggestions
        let hasExactMatch = false;
        try {
            const exactResults = window.tinysearchSearch(lowerQuery, 1);
            hasExactMatch = exactResults.length > 0;
        } catch (error) {
            // Ignore search errors for exact match check
        }

        if (
            !hasExactMatch &&
            partialMatches.length > 0 &&
            lastWord.length < 5
        ) {
            // Show suggestions
            displaySuggestions(query, lastWord, partialMatches);
            currentSuggestions = partialMatches;
        } else {
            // Perform full search
            currentSuggestions = [];
            try {
                const results = window.tinysearchSearch(lowerQuery, 20);

                // If no exact results but we have partial matches, search with them
                if (results.length === 0 && partialMatches.length > 0) {
                    const suggestionResults = [];
                    for (const suggestion of partialMatches.slice(0, 3)) {
                        const suggestionQuery = words
                            .slice(0, -1)
                            .concat(suggestion)
                            .join(" ");
                        try {
                            const partialResults = window.tinysearchSearch(
                                suggestionQuery.toLowerCase(),
                                5,
                            );
                            suggestionResults.push(
                                ...partialResults.map((r) => [
                                    ...r,
                                    suggestion,
                                ]),
                            );
                        } catch (e) {
                            // Ignore errors for individual suggestions
                        }
                    }
                    displayMixedResults(suggestionResults, query);
                } else {
                    displayResults(results, query);
                }
            } catch (error) {
                console.error("Search error:", error);
                searchResults.innerHTML =
                    '<div class="search-no-results">An error occurred while searching.</div>';
            }
        }
    }

    // Display suggestions
    function displaySuggestions(
        query: string,
        partial: string,
        suggestions: string[],
    ) {
        const limitedSuggestions = suggestions.slice(0, 5);
        const html = `
            <div class="search-suggestions">
                <p class="search-suggestions-label">Did you mean:</p>
                <div class="search-suggestions-list">
                    ${limitedSuggestions
                        .map(
                            (suggestion, index) => `
                        <button class="search-suggestion-item" data-suggestion="${escapeHtml(suggestion)}" data-index="${index}">
                            <span class="search-suggestion-shortcut">${index + 1}</span>
                            ${escapeHtml(suggestion)}
                        </button>
                    `,
                        )
                        .join("")}
                </div>
                <p class="search-suggestions-note">Search full words. You can find results in headlines, content text, alt tags & more.</p>
            </div>
        `;
        searchResults.innerHTML = html;

        // Add click handlers to suggestions
        document.querySelectorAll(".search-suggestion-item").forEach((btn) => {
            btn.addEventListener("click", (e) => {
                const suggestion = (e.target as HTMLElement).getAttribute(
                    "data-suggestion",
                );
                if (suggestion) {
                    const words = query.toLowerCase().split(/\s+/);
                    words[words.length - 1] = suggestion;
                    searchInput.value = words.join(" ");
                    performSearch(searchInput.value);
                }
            });
        });
    }

    // Display mixed results with suggestions
    function displayMixedResults(
        results: Array<[string, string, string]>,
        query: string,
    ) {
        if (!results || results.length === 0) {
            searchResults.innerHTML =
                '<div class="search-no-results">No results found.</div>';
            return;
        }

        // Group results by suggestion word
        const groupedResults: { [key: string]: Array<[string, string]> } = {};
        results.forEach(([title, url, suggestion]) => {
            if (!groupedResults[suggestion]) {
                groupedResults[suggestion] = [];
            }
            groupedResults[suggestion].push([title, url]);
        });

        let html = '<div class="search-mixed-results">';

        for (const [suggestion, suggestionResults] of Object.entries(
            groupedResults,
        )) {
            html += `
                <div class="search-suggestion-group">
                    <p class="search-suggestion-header">Results for "${escapeHtml(suggestion)}":</p>
                    <ul class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 2xl:grid-cols-5 gap-4 2xl:max-w-[1600px] 2xl:mx-auto">
            `;

            const enrichedResults = suggestionResults.map(([title, url]) => {
                const indexItem = window.searchIndex?.find(
                    (item) => item.url === url || item.title === title,
                );
                const body = indexItem?.body || "";
                const firstSentence = body.match(/^[^.!?]+[.!?]/)?.[0] || "";
                const description = firstSentence || body.substring(0, 150);
                return { title, url, body, description };
            });

            html += enrichedResults
                .map((result) => {
                    const escapedTitle = escapeHtml(result.title);
                    const escapedDescription = escapeHtml(
                        result.description.trim(),
                    );
                    const matchingContext =
                        findMatchingContext(result.body, suggestion) ||
                        escapeHtml(result.body.substring(0, 300)) + "...";

                    return `
                <li>
                    <article class="search-result-item">
                        <a href="${result.url}" class="search-result-link">
                            <div class="flex-grow">
                                <h3 class="search-result-title">${escapedTitle}</h3>
                                ${escapedDescription ? `<p class="search-result-description">${escapedDescription}</p>` : ""}
                                <div class="search-result-content">
                                    <p>${matchingContext}</p>
                                </div>
                            </div>
                            <div class="search-result-fade"></div>
                        </a>
                    </article>
                </li>
            `;
                })
                .join("");

            html += `
                    </ul>
                </div>
            `;
        }

        html += "</div>";
        searchResults.innerHTML = html;
    }

    // Display search results
    function displayResults(results: any[], query: string) {
        if (!results || results.length === 0) {
            searchResults.innerHTML =
                '<div class="search-no-results">No results found.</div>';
            return;
        }

        // Map results to include full content from search index
        const enrichedResults = results.map(([title, url]) => {
            const indexItem = window.searchIndex?.find(
                (item) => item.url === url || item.title === title,
            );
            // Extract description from body (first sentence or first 150 chars)
            const body = indexItem?.body || "";
            const firstSentence = body.match(/^[^.!?]+[.!?]/)?.[0] || "";
            const description = firstSentence || body.substring(0, 150);
            return { title, url, body, description };
        });

        const resultsHtml = enrichedResults
            .map((result) => {
                const escapedTitle = escapeHtml(result.title);
                const escapedDescription = escapeHtml(
                    result.description.trim(),
                );
                const matchingContext =
                    findMatchingContext(result.body, query) ||
                    escapeHtml(result.body.substring(0, 300)) + "...";

                return `
                    <li>
                        <article class="search-result-item">
                            <a href="${result.url}" class="search-result-link">
                                <div class="flex-grow">
                                    <h3 class="search-result-title">${escapedTitle}</h3>
                                    ${escapedDescription ? `<p class="search-result-description">${escapedDescription}</p>` : ""}
                                    <div class="search-result-content">
                                        <p>${matchingContext}</p>
                                    </div>
                                </div>
                                <div class="search-result-fade"></div>
                            </a>
                        </article>
                    </li>
                `;
            })
            .join("");

        searchResults.innerHTML = `<ul class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 2xl:grid-cols-5 gap-4 2xl:max-w-[1600px] 2xl:mx-auto">${resultsHtml}</ul>`;
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text: string): string {
        const map: { [key: string]: string } = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, (m) => map[m]);
    }

    // Show search
    function showSearch() {
        searchContainer.classList.remove("hidden");
        document.body.style.overflow = "hidden";
        searchInput.focus();
        searchInput.value = "";
        searchResults.innerHTML = "";
    }

    // Hide search
    function hideSearch() {
        searchContainer.classList.add("hidden");
        document.body.style.overflow = "";
        searchInput.value = "";
        searchResults.innerHTML = "";
    }

    // Set up event listeners
    function setupEventListeners() {
        // Close button
        searchClose.addEventListener("click", hideSearch);

        // Search input
        let searchTimeout: NodeJS.Timeout;
        searchInput.addEventListener("input", (e) => {
            clearTimeout(searchTimeout);
            const query = (e.target as HTMLInputElement).value;
            searchTimeout = setTimeout(() => performSearch(query), 300);
        });

        // Keyboard shortcuts
        document.addEventListener("keydown", (e) => {
            // Cmd+P or Ctrl+P to open search
            if ((e.metaKey || e.ctrlKey) && e.key === "p") {
                e.preventDefault();
                showSearch();
            }

            // Escape to close search
            if (
                e.key === "Escape" &&
                !searchContainer.classList.contains("hidden")
            ) {
                hideSearch();
            }

            // Cmd+Option+1-5 for suggestions
            if (
                (e.metaKey || e.ctrlKey) &&
                e.altKey &&
                !searchContainer.classList.contains("hidden")
            ) {
                const num = parseInt(e.key);
                if (num >= 1 && num <= 5) {
                    e.preventDefault();
                    const suggestionBtn = document.querySelector(
                        `.search-suggestion-item[data-index="${num - 1}"]`,
                    ) as HTMLButtonElement;
                    if (suggestionBtn) {
                        suggestionBtn.click();
                    }
                }
            }
        });
    }

    // Initialize on page load
    if (typeof window !== "undefined") {
        document.addEventListener("DOMContentLoaded", () => {
            initializeElements();
            setupEventListeners();
            // Pre-initialize WASM, search index, and word index in the background
            Promise.all([initializeWasm(), loadSearchIndex(), loadWordIndex()]);
        });
    }
</script>
