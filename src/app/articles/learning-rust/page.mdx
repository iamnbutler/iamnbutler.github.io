import { ArticleLayout } from '@/components/ArticleLayout'

export const article = {
  author: 'Nate Butler',
  date: '2023-10-04',
  title: 'Journey: Learning Rust',
  description:
    'Ahh Rust, the language that everyone is talking about. I’ve been interested in Rust for a while now due to Zed being written in it, but the barrier to entry has always felt so high. I’ve been learning bit by bit and wanted to document my journey.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

Ahh Rust, the language that everyone is talking about. I’ve been interested in Rust for a while now due to Zed being written in it, but the barrier to entry has always felt so high.

I’ve been learning bit by bit and wanted to document my journey.

## Why learn Rust?

I find Rust really interesting – despite being notoriously difficult to learn people seem to love it. I've seen some of what it has been capable of while working at Zed, and it seems like a great language to learn.

While I've really enjoyed learning to write TypeScript over the past two years, I often get the feeling that you need to manually implement type safety into your code, sometimes multiple times and then it still can be user error that types are not enforced correctly.

I'm curious to feel out how working in a statically typed language that is designed to be safe by default feels. I'm sure I'm diving in far over my head, but hey, that's how I learn ¯&bsol;&lowbar;(ツ)&lowbar;/¯

## October 2023 – Using Diesel and Sqlite with Rust

Currently, I'm working through building out a simple tasks app, with support for both one-time tasks and repeating tasks (like a combined todo list and routine tracker.)

I'm using [Diesel](https://diesel.rs/) as an ORM and [Sqlite](https://www.sqlite.org/index.html) as a database.

Diesel is interesing. Somewhat opposite of something like Prisma in TypesScript-land, in Diesel you define the shape of your data in Rust and then Diesel generates the SQL for you.

For example, if I have a table called `tasks`, I can create some structs in Rust that look like this:

```rust
// models.rs
use crate::schema::tasks;
use diesel::prelude::*;

#[derive(Queryable, Selectable)]
#[diesel(table_name = crate::schema::tasks)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct Task {
    pub id: i32,
    pub title: String,
    pub description: Option<String>,
}

#[derive(Insertable)]
#[diesel(table_name = tasks)]
pub struct NewTask {
    pub title: String,
    pub description: Option<String>,
}
```

(The lack of a `completed` field here is because we will use a seperate `task_completion` table to track completions to support repeating tasks.)

--- Work in progress! ---
